#+OPTIONS: toc:t
#+TITLE:    Lodox
#+SUBTITLE: Like Codox for LFE.
#+DATE:     2015-10-31
#+AUTHOR:   Eric Bailey
#+EMAIL:    quasiquoting@gmail.com
#+LANGUAGE: en
#+CREATOR:  Emacs 24.5.1 (Org mode 8.3.2)

#+NAME: lodox-version
#+BEGIN_SRC sh :exports none
cat VERSION
#+END_SRC

* Literate Programming Setup
Set [[http://orgmode.org/manual/Code-evaluation-security.html#index-org_002dconfirm_002dbabel_002devaluate-2148][~org-confirm-babel-evaluate~]] to a ~lambda~ expression that takes the
~lang~-uage and ~body~ of a code block and returns ~nil~ if ~lang~ is
=​"emacs-lisp"​= or =​"sh"​=, otherwise ~t~.
#+NAME: auto-eval-elisp
#+BEGIN_SRC emacs-lisp :results silent
(setq-local org-confirm-babel-evaluate
            (lambda (lang body)
              (not (or (string= lang "emacs-lisp")
                       (string= lang "sh")))))
#+END_SRC

Define an Emacs Lisp code block called =generated= that takes a ~lang~-uage
(default: ~​"lfe"​~) and produces a commented notice that source code in this
project is generated by this Org file.
#+NAME: generated
#+BEGIN_SRC emacs-lisp :var lang="lfe"
(let ((comment (cond
                ((string= lang "erlang")        "%%%")
                ((member lang '("conf" "yaml")) "###")
                (t                              ";;;")))
      (line    (make-string 67 ?=))
      (warning "This file was generated by Org. Do not edit it directly.")
      (how-to  "Instead, edit Lodox.org in Emacs and call org-babel-tangle."))
  (format "%s%s\n%s %s\n%s %s\n%s%s\n\n"
          comment line
          comment warning
          comment how-to
          comment line))
#+END_SRC

For example, ~<<generated("lfe")>>~ produces:
#+BEGIN_SRC text :noweb yes
<<generated("lfe")>>
#+END_SRC

Tangle the literate Lodox source.
#+BEGIN_SRC emacs-lisp :exports code :results silent
(declare-function org-babel-tangle "ob-tangle")

(defconst lodox-literate-source (buffer-file-name))

(defun quasiquoting/tangle-literate-lodox-source ()
  "Upon saving the Lodox README.org, tangle it."
  (when (file-equal-p buffer-file-name lodox-literate-source)
    (org-babel-tangle-file "LICENSE.org")
    (org-babel-tangle)))

;; (add-hook 'after-save-hook 'quasiquoting/tangle-literate-lodox-source)
#+END_SRC
N.B. The ~after-save-hook~ is disabled for now.

* Git config
  :PROPERTIES:
  :noweb:    yes
  :padline:  no
  :END:
** .gitignore
   :PROPERTIES:
   :tangle:   ../.gitignore
   :END:
#+BEGIN_SRC conf :exports none
## -*- conf -*-
<<generated("conf")>>
#+END_SRC
#+BEGIN_SRC conf
.DS_Store
_*
*.beam
ebin
erl_crash.dump
rebar.lock
#+END_SRC

** Submodules
   :PROPERTIES:
   :tangle:   ../.gitmodules
   :END:
#+BEGIN_SRC conf :exports none
<<generated("conf")>>
#+END_SRC
#+BEGIN_SRC conf
[submodule "doc"]
path   = doc
url    = git@github.com:quasiquoting/lodox.git
branch = gh-pages
#+END_SRC

* Application Resource File
  :PROPERTIES:
  :tangle:   ../src/lodox.app.src
  :noweb:    yes
  :END:
#+BEGIN_SRC erlang :exports none
<<generated("erlang")>>
#+END_SRC
#+BEGIN_SRC erlang :padline yes :tangle ../src/lodox.app.src
{application,    'lodox',
 [{description,  "The LFE rebar3 Lodox plugin"},
  {vsn,          "<<lodox-version()>>"},
  {modules,      ['lodox-html-writer','lodox-org-writer',
                  'lodox-p','lodox-parse','lodox-util',
                  lodox,
                  'unit-lodox-tests']},
  {registered,   []},
  {applications, [kernel, stdlib]},
  {env,
   [{'source-uri',
     "https://github.com/quasiquoting/lodox/blob/master/{filepath}#L{line}"}]}]}.
#+END_SRC

* Rebar3 Configuration
  :PROPERTIES:
  :exports:  none
  :tangle:   no
  :noweb:    yes
  :padline:  no
  :END:
*Describe =rebar.config= here.*

#+BEGIN_SRC erlang :tangle ../rebar.config
<<generated("erlang")>>
#+END_SRC
#+BEGIN_SRC erlang :exports code :tangle ../rebar.config
{erl_opts, [debug_info, {src_dirs, ["test"]}]}.

{eunit_compile_opts, [{src_dirs, ["test"]}]}.

{provider_hooks, [{pre, [{compile, {lfe, compile}}]}]}.
#+END_SRC

The first and foremost dependency is, of course, [[https://github.com/rvirding/lfe][LFE]] itself.
Use the latest version, which as of this writing, is:
#+NAME: lfe-version
: 0.10.1

#+NAME: lfe
#+BEGIN_SRC erlang
{lfe,      {git, "git://github.com/rvirding/lfe.git", {tag, "<<lfe-version()>>"}}}
#+END_SRC

To make writing [[http://www.erlang.org/doc/apps/eunit/chapter.html][EUnit]] tests easier, use [[https://github.com/lfex/ltest][ltest]].

#+NAME: ltest-version
: 0.7.0

#+NAME: ltest
#+BEGIN_SRC erlang
{ltest,    {git, "git://github.com/lfex/ltest.git", {tag, "<<ltest-version()>>"}}}
#+END_SRC

For the Clojure-inspired threading macros, use [[https://github.com/lfex/clj][clj]].

#+NAME: clj-version
: 0.3.0

#+NAME: clj
#+BEGIN_SRC erlang
{clj,      {git, "git://github.com/lfex/clj.git", {tag, "0.3.0"}}}
#+END_SRC


To handle HTML rendering, use [[https://github.com/lfex/exemplar][exemplar]].

N.B. Only using [[https://github.com/yurrriq/exemplar][my fork]] until [[https://github.com/lfex/exemplar/pull/15][this pull request]] or similar
gets merged into the [[https://github.com/lfex][lfex]] repo.

#+NAME: exemplar-version
: 0.3.0

#+NAME: exemplar
#+BEGIN_SRC erlang
{exemplar, {git, "git://github.com/yurrriq/exemplar.git", {tag, "<<exemplar-version()>>"}}}
#+END_SRC

For markdown: [[https://github.com/erlware/erlmarkdown][erlmarkdown]].

#+NAME: markdown
#+BEGIN_SRC erlang
{markdown, {git, "git://github.com/erlware/erlmarkdown.git"}}
#+END_SRC

#+NAME: proper
#+BEGIN_SRC erlang
{proper,
 {git, "git://github.com/quasiquoting/proper.git",
  {branch, "master"}}}
#+END_SRC

#+BEGIN_SRC erlang :exports code :padline yes :tangle ../rebar.config
{deps,
 [<<lfe>>,
  <<ltest>>,
  <<clj>>,
  <<exemplar>>,
  <<markdown>>,
  <<proper>>]}.
#+END_SRC

* Modules
  :PROPERTIES:
  :noweb:    yes
  :END:
** lodox
   :PROPERTIES:
   :tangle:   ../src/lodox.lfe
   :padline:  yes
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+BEGIN_SRC lfe
(defmodule lodox
  (doc "The Lodox [Rebar3][1] [provider][2].

[1]: http://www.rebar3.org/docs/plugins
[2]: https://github.com/tsloughter/providers ")
  (behaviour provider)
  (export all))
#+END_SRC
*** [[http://www.rebar3.org/v3.0/docs/plugins#section-provider-interface][Provider Interface]]
- /namespace/: in which the provider is registered.
  In this case, use ~default~, which is the main namespace.
#+BEGIN_SRC lfe
(defun namespace ()
  "The namespace in which `lodox` is registered, `default`."
  'default)
#+END_SRC

- /name/: The 'user friendly' name of the task.
#+BEGIN_SRC lfe
(defun provider-name ()
  "The 'user friendly' name of the task, `lodox`."
  'lodox)
#+END_SRC

- /short​_desc/: A one line, short description of the task, used in lists of
  providers.
#+BEGIN_SRC lfe
(defun short-desc ()
  "A one line, short description of the task, used in lists of providers."
  "Generate documentation from LFE source files.")
#+END_SRC

- /deps/: The list of dependencies, providers, that need to run before this
  one. You do not need to include the dependencies of your dependencies.
#+BEGIN_SRC lfe
(defun deps ()
  "The list of dependencies, providers, that need to run before this one."
  '(#(default app_discovery)))
#+END_SRC

- /desc/: The description for the task, used by ~rebar3 help~.
#+BEGIN_SRC lfe
(defun desc ()
  "The description for the task, used by `rebar3 help`."
  (short-desc))
#+END_SRC

#+BEGIN_SRC lfe :exports none :padline no
#+END_SRC
#+BEGIN_SRC lfe :exports none
;;;===================================================================
;;; API
;;;===================================================================
#+END_SRC

~init/1~ is called when ~rebar3~ first boots and simply initiates the provider
and sets up the state.
#+BEGIN_SRC lfe
(defun init (state)
  "Initiate the Lodox provider."
  (rebar_api:debug "Initializing {default, lodox}" '())
  (let* ((opts `(#(name       ,(provider-name)) ; The 'user friendly' name
                 #(module     ,(MODULE))        ; The module implementation
                 #(namespace  ,(namespace))     ; Plugin namespace
                 #(opts       ())               ; List of plugin options
                 #(deps       ,(deps))          ; The list of dependencies
                 #(example    "rebar3 lodox")   ; How to use the plugin
                 #(short_desc ,(short-desc))    ; A one-line description
                 #(desc       ,(desc))          ; A longer description
                 #(bare       true)))           ; Task can be run by user
         (provider (providers:create opts)))
    (let ((state* (rebar_state:add_provider state provider)))
      (rebar_api:debug "Initialized lodox" '())
      `#(ok ,state*))))
#+END_SRC

~do/1~ parses the rebar state for the ~current_app~ (as a singleton list) or the
list of ~project_apps~ and calls ~write-docs/1~ on each one. This is where the
actual work happens.
#+BEGIN_SRC lfe
(defun do (state)
  "Generate documentation for each application in the project.

See: [[lodox-html-writer:write-docs/2]]"
  (rebar_api:debug "Starting do/1 for lodox" '())
  (let ((apps (case (rebar_state:current_app state)
                ('undefined (rebar_state:project_apps state))
                (apps-info   `(,apps-info)))))
    (lists:foreach #'write-docs/1 apps))
  `#(ok ,state))
#+END_SRC

~format_error/1~ prints errors when they happen. The point is to enable
filtering of sensitive elements from the state, but in this case, it simply
prints the ~reason~.
#+BEGIN_SRC lfe
(defun format_error (reason)
  "When an exception is raised or a value returned as
`#(error #((MODULE) reason)`, `(format_error reason)` will be called
so a string can be formatted explaining the issue."
  (io_lib:format "~p" `(,reason)))
#+END_SRC

*** Internal Functions
#+BEGIN_SRC lfe :exports none :padline no
#+END_SRC
#+BEGIN_SRC lfe :exports none
;;;===================================================================
;;; Internal functions
;;;===================================================================
#+END_SRC

~write-docs/1~ takes an ~app_info_t~ (see: [[https://github.com/rebar/rebar3/blob/master/src/rebar_app_info.erl][rebar​_app​_info.erl]]) and generates
documentation for it.
#+BEGIN_SRC lfe
(defun write-docs (app-info)
  (let* ((`(,opts ,app-dir ,name ,vsn ,out-dir)
          (lists:map (lambda (f) (call 'rebar_app_info f app-info))
                     '(opts dir name original_vsn out_dir)))
         (ebin-dir (filename:join out-dir "ebin"))
         (doc-dir  (filename:join app-dir "doc")))
    (rebar_api:debug "Adding ~p to the code path" `(,ebin-dir))
    (code:add_path ebin-dir)
    (let ((project (lodox-parse:docs name))
          (opts    `#m(output-path ,doc-dir app-dir ,app-dir)))
      (rebar_api:debug "Generating docs for ~p" `(,(mref project 'name)))
      (lodox-html-writer:write-docs project opts))
    (generated name vsn doc-dir)))
#+END_SRC

~generated/3~ takes an app ~name~, ~vsn~ and output directory and prints a line
describing the docs that were generated.
#+BEGIN_SRC lfe
(defun generated
  ([name `#(cmd ,cmd) doc-dir]
   (generated name (os:cmd (++ cmd " | tr -d \"\\n\"")) doc-dir))
  ([name vsn doc-dir]
   (rebar_api:console "Generated ~s v~s docs in ~s" `(,name ,vsn ,doc-dir))))
#+END_SRC

** lodox-html-writer
   :PROPERTIES:
   :tangle:   ../src/lodox-html-writer.lfe
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox-html-writer.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+BEGIN_SRC lfe
(defmodule lodox-html-writer
  (doc "Documentation writer that outputs HTML.")
  (export (write-docs 1) (write-docs 2)))

(include-lib "clj/include/compose.lfe")

(include-lib "exemplar/include/html-macros.lfe")

(include-lib "lodox/include/lodox-macros.lfe")


(defun write-docs (project)
  "Equivalent to [[write-docs/2]] with `[]` as `opts`."
  (write-docs project #m()))

(defun write-docs (project opts)
  "Take raw documentation info and turn it into formatted HTML."
  (let* ((`#(ok ,cwd) (file:get_cwd))
         (`#m(output-path ,output-path app-dir ,app-dir)
          (maps:merge `#m(output-path "doc" app-dir ,cwd) opts))
         (project* (mset project 'app-dir app-dir)))
    (doto output-path
          (mkdirs '("css" "js"))
          (copy-resource "css/default.css")
          (copy-resource "css/hk-pyg.css")
          (copy-resource "js/jquery.min.js")
          (copy-resource "js/page_effects.js")
          (write-index project*)
          (write-modules project*)
          (write-libs project*))))

(defun include-css (style)
  (link `(type "text/css" href ,style rel "stylesheet")))

(defun include-js (script)
  (script `(type "text/javascript" src ,script)))

(defun link-to (uri content)
  "```html
<a href=\"{{uri}}\">{{content}}</a>
```"
  (a `(href ,uri) content))

(defun func-id
  ([func] (when (is_map func))
   (func-id (func-name func)))
  ([fname] (when (is_list fname))
   (-> (http_uri:encode (h fname))
       (re:replace "%" "." '(global #(return list)))
       (->> (++ "func-")))))

(defun format-docstring (project m) (format-docstring project '() m))

(defun format-docstring (project module func)
  (format-docstring project module func (maps:get 'format func 'markdown)))

(defun format-docstring
  ([project _ m 'plaintext]
   (pre '(class "plaintext") (h (mref m 'doc))))
  ([project mod m 'markdown]
   (case (mref m 'doc)
     ('() (br))
     (doc
      (format-wikilinks
       project (markdown->html (unicode:characters_to_list doc))
       (if (is_map mod)
         (maps:get 'name mod 'undefined)
         (mref m 'name)))))))

(defun markdown->html (markdown)
  "Given a Markdown string, convert it to HTML.
Use [pandoc] if available, otherwise [erlmarkdown].

[pandoc]: http://pandoc.org
[erlmarkdown]: https://github.com/erlware/erlmarkdown"
  (case (os:find_executable "pandoc")
    ('false (markdown:conv_utf8 markdown))
    (pandoc (->> `[,pandoc ,(escape markdown)]
                 (io_lib:format "~s -f markdown_github -t html <<< \"~s\"")
                 (lists:flatten)
                 (os:cmd)))))

(defun format-wikilinks
  ([`#m(modules ,modules) html starting-mod]
   (case (re:run html "\\[\\[([^\\[]+/\\d+)\\]\\]"
                 '[global #(capture all_but_first)])
     (`#(match ,matches)
      (-> (match-lambda
            ([`#(,start ,length)]
             (let ((match (lists:sublist html (+ 1 start) length)))
               (case (lodox-util:search-funcs modules match starting-mod)
                 ('undefined
                  'false)
                 (mfa
                  (let ((`#(,mod [,_ . ,fname])
                         (lists:splitwith (lambda (c) (=/= c #\:)) mfa)))
                    `#(true #(,(re-escape (++ "[[" match "]]"))
                              ,(link-to (func-uri mod fname)
                                 (if (=:= (atom_to_list starting-mod) mod)
                                   (h fname)
                                   (h (++ mod ":" fname))))))))))))
          (lists:filtermap (lists:flatten matches))
          (->> (fold-replace html))))
     ('nomatch html))))

(defun index-by (k ms) (lists:foldl (lambda (m mm) (mset mm (mref m k) m)) (map) ms))

(defun mod-filename
  ([mod] (when (is_map mod))
   (mod-filename (mod-name mod)))
  ([mname] (when (is_list mname))
   (++ mname ".html")))

(defun mod-filepath (output-dir module)
  (filename:join output-dir (mod-filename module)))

(defun mod-name (mod) (atom_to_list (mref mod 'name)))

(defun doc-filename (doc)
  (++ (mref doc 'name) ".html"))

(defun doc-filepath (output-dir doc)
  (filename:join output-dir (doc-filename doc)))

(defun func-uri (module func)
  (++ (mod-filename module) "#" (func-id func)))

(defun func-source-uri (source-uri project module func)
  (let* ((filepath1 (mref module 'filepath))
         (filepath2 (lists:nthtail (+ 1 (length (mref project 'app-dir))) filepath1))
         (line      (mref func 'line))
         (uri1 (re:replace source-uri "{filepath}" filepath2 '(#(return list)))))
    (re:replace uri1 "{line}" (integer_to_list line) '(#(return list)))))

(defun index-link (project on-index?)
  `(,(h3 '(class "no-link") (span '(class "inner") "Application"))
    ,(ul '(class "index-link")
         (li `(class ,(++ "depth-1" (if on-index? " current" "")))
             (link-to "index.html" (div '(class "inner") "Index"))))))

(defun includes-menu (project current-lib)
  (let* ((libs    (mref project 'libs))
         (lib-map (index-by 'name libs)))
    `(,(h3 '(class "no-link") (span '(class "inner") "Includes"))
      ,(ul
         (lists:map
           (match-lambda
             ([`#(,lib-name ,lib)]
              (let ((class (++ "depth-1" (if (=:= lib current-lib)
                                           " current"
                                           "")))
                    (inner (div '(class "inner") (h (atom_to_list lib-name)))))
                (li `(class ,class) (link-to (mod-filename lib) inner)))))
           (maps:to_list lib-map))))))

(defun modules-menu (project current-mod)
  (let* ((modules (mref project 'modules))
         (mod-map (index-by 'name modules)))
    `(,(h3 '(class "no-link") (span '(class "inner") "Modules"))
      ,(ul
         (lists:map
           (match-lambda
             ([`#(,mod-name ,mod)]
              (let ((class (++ "depth-1" (if (=:= mod current-mod)
                                           " current"
                                           "")))
                    (inner (div '(class "inner") (h (atom_to_list mod-name)))))
                (li `(class ,class) (link-to (mod-filename mod) inner)))))
           (maps:to_list mod-map))))))

(defun primary-sidebar (project) (primary-sidebar project '()))

(defun primary-sidebar (project current)
  (div '(class "sidebar primary")
    `(,(index-link project (=:= '() current))
      ,(includes-menu project current)
      ,(modules-menu project current))))

(defun sorted-exported-funcs (module)
  (lists:sort
    (lambda (a b)
      (=< (string:to_lower (func-name a))
          (string:to_lower (func-name b))))
    (mref module 'exports)))

(defun funcs-sidebar (module)
  (div '(class "sidebar secondary")
    `(,(h3 (link-to "#top" (span '(class "inner") "Exports")))
      ,(ul
         (lists:map
           (lambda (func)
             `(,(li '(class "depth-1")
                    (link-to (func-uri module func)
                      (div '(class "inner")
                        (span (h (func-name func)))))))) ; TODO: members?
           (sorted-exported-funcs module))))))

(defun default-includes ()
  `(,(meta '(charset "UTF-8"))
    ,(include-css "css/default.css")
    ,(include-css "css/hk-pyg.css")
    ,(include-js "js/jquery.min.js")
    ,(include-js "js/page_effects.js")))

(defun project-title (project)
  (span '(class "project-title")
        `(,(span '(class "project-name")    (h (mref project 'name))) " "
          ,(span '(class "project-version") (h (mref project 'version))))))

(defun header* (project)
  (div '(id "header")
    `(,(h2 `("Generated by "
             ,(link-to "https://github.com/quasiquoting/lodox" "Lodox")))
      ,(h1 (link-to "index.html" (project-title project))))))

;; TODO: package in ld-parse
(defun package (project)
  (maps:get 'package project ""))

(defun index-page (project)
  (html
    `(,(head
         `(,(default-includes)
           ,(title (++ (h (mref project 'name)) " "
                       (h (mref project 'version))))))
      ,(body
         `(,(header* project)
           ,(primary-sidebar project)
           ,(div '(id "content" class "module-index")
              `(,(h1 (project-title project))
                ,(div '(class "doc") (p (h (mref project 'description))))
                ,(case (package project)
                   ("" '())
                   (pkg
                    `(,(h2 "Installation")
                      ,(p "To install, add the following dependency to your rebar.config:")
                      ,(pre '(class "deps")
                         (h (++ "[" pkg " " (mref project 'version) "]"))))))
                ;; TODO: includes
                ,(h2 "Modules")
                ,(lists:map
                   (lambda (module)
                     (div '(class "module")
                       `(,(h3 (link-to (mod-filename module)
                                (h (mod-name module))))
                         ;; TODO: module doc
                         ,(div '(class "index")
                            `(,(p "Exports")
                              ,(unordered-list
                                (lists:map
                                  (lambda (func)
                                    `(" "
                                      ,(link-to (func-uri module func)
                                         (func-name func))
                                      " "))
                                  (sorted-exported-funcs module))))))))
                   (lists:sort
                     (lambda (a b) (=< (mod-name a) (mod-name b)))
                     (mref project 'modules))))))))))

;; TODO: exemplar-ify this
(defun unordered-list (lst) (ul (lists:map #'li/1 lst)))

#|
(defun format-document
  ([project (= doc `#m(format ,format))] (when (=:= format 'markdown))
   ;; TODO: render markdown
   `(div (class "markdown") ,(mref doc 'content))))

(defun document-page (project doc)
  (html
    (head
      `(,(default-includes)
        ,(title (h (mref doc 'title)))))
    (body
      `(,(header* project)
        ,(primary-sidebar project doc)
        ,(div '(id "content" class "document")
           (div '(id "doc") (format-document project doc)))))))
|#

(defun func-usage (func)
  (lists:map
    (lambda (arglist)
      (re:replace (lfe_io_pretty:term arglist) "comma " ". ,"
                  '[global #(return list)]))
    (mref func 'arglists)))

(defun mod-behaviour (mod)
  (lists:map
    (lambda (behaviour)
      (h4 '(class "behaviour") (atom_to_list behaviour)))
    (mref mod 'behaviour)))

(defun func-docs (project module func)
  (div `(class "public anchor" id ,(h (func-id func)))
    `(,(h3 (h (func-name func)))
      ,(case (func-usage func)
         ('("()") '())
         (usages
          (div '(class "usage")
            (-> `["```commonlisp"
                  ,@(lists:map #'unicode:characters_to_list/1 usages)
                  "```"]
                (string:join "\n")
                (markdown->html)))))
      ,(div '(class "doc")
         (format-docstring project module func))
      ;; TODO: members?
      ,(let ((app (binary_to_atom (mref project 'name) 'latin1)))
         (case (application:get_env app 'source-uri)
           ('undefined '())             ; Log failure to generate link?
           (`#(ok ,source-uri)
            (div '(class "src-link")
              (link-to (func-source-uri source-uri project module func)
                "view source"))))))))

(defun module-page (project module)
  (html
    `(,(head
         `(,(default-includes)
           ,(title (++ (h (mod-name module)) " documentation"))))
      ,(body
         `(,(header* project)
           ,(primary-sidebar project module)
           ,(funcs-sidebar module)
           ,(div '(id "content" class "module-docs")
              `(,(h1 '(id "top" class "anchor") (h (mod-name module)))
                ,(mod-behaviour module)
                ,(div '(class "doc") (format-docstring project '() module))
                ,(lists:map (lambda (func) (func-docs project module func))
                            (sorted-exported-funcs module)))))))))

(defun lib-page (project lib)
  (html
    `(,(head
         `(,(default-includes)
           ,(title (++ (h (mref lib 'name)) " documentation"))))
      ,(body
         `(,(header* project)
           ,(primary-sidebar project lib)
           ,(funcs-sidebar lib)
           ,(div '(id "content" class "module-docs") ; TODO: confirm this
              `(,(h1 '(id "top" class "anchor") (h (mref lib 'name)))
                ,(lists:map (lambda (func) (func-docs project lib func))
                            (sorted-exported-funcs lib)))))))))

(defun copy-resource (output-dir resource)
  (let* ((this  (proplists:get_value 'source (module_info 'compile)))
         (lodox (filename:dirname (filename:dirname this))))
    (file:copy (filename:join `(,lodox "resources" ,resource))
               (filename:join output-dir resource))))

(defun mkdirs (output-dir dirs)
  (file:make_dir output-dir)
  (flet ((mkdir (dir) (file:make_dir (filename:join output-dir dir))))
    (lists:foreach #'mkdir/1 dirs)))

(defun write-index (output-dir project)
  (file:write_file (filename:join output-dir "index.html")
                   (index-page project)))

(defun write-modules (output-dir project)
  (flet ((write-module (module)
           (-> (mod-filepath output-dir module)
               (file:write_file (module-page project module)))))
    (lists:foreach #'write-module/1 (mref project 'modules))))

(defun write-libs (output-dir project)
  (flet ((write-lib (lib)
           (file:write_file (mod-filepath output-dir lib)
                            (lib-page project lib))))
    (lists:foreach #'write-lib/1 (mref project 'libs))))

#|
(defun write-documents (output-dir project)
  (flet ((write-document (document)
           (-> (doc-filepath output-dir document)
               (file:write_file (document-page project document)))))
    (lists:foreach #'write-document/1 (mref project 'documents))))
|#

(defun func-name (func)
  (++ (h (mref func 'name)) "/" (integer_to_list (mref func 'arity))))

(defun h (text)
  "Convenient alias for escape-html/1."
  (escape-html text))

(defun escape-html
  "Change special characters into HTML character entities."
  ([x] (when (is_atom x))
   (escape-html (atom_to_list x)))
  ([text]
   (fold-replace text '(#("\\&"  "\\&amp;")
                        #("<"  "\\&lt;")
                        ;; #(">"  "\\&gt;")
                        #("\"" "\\&quot;")
                        #("'"  "\\&apos;")))))

(defun escape (string)
  "Given a string, return a copy with backticks and double quotes escaped."
  (re:replace string "[`\"]" "\\\\&" '[global #(return list)]))

(defun fold-replace (string pairs)
  (-> (match-lambda
        ([`#(,patt ,replacement) acc]
         (re:replace acc patt replacement '(global #(return list)))))
      (lists:foldl string pairs)))

;; Stolen from Elixir
;; https://github.com/elixir-lang/elixir/blob/944990381f6cadbaf751f2443d485684ba35b6d8/lib/elixir/lib/regex.ex#L601-L619
(defun re-escape (string)
  (re:replace string "[.^$*+?()[{\\\|\s#]" "\\\\&" '[global  #(return list)]))
#+END_SRC

** lodox-parse
   :PROPERTIES:
   :tangle:   ../src/lodox-parse.lfe
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox-parse.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+BEGIN_SRC lfe
(defmodule lodox-parse
  (doc "Parsing LFE source files for metadata.")
  (export (docs 1)
          (form-doc 1)
          (macro-doc 1)
          (lib-docs 0) (lib-docs 1) (lib-doc 1)
          (script-doc 1)
          (documented 1))
  (import (from lodox-p
            (arglist? 1)
            (macro-clauses? 1) (macro-clause? 1)
            (clauses? 1) (clause? 1)
            (string? 1)
            (null? 1))))

(include-lib "clj/include/compose.lfe")

(include-lib "lodox/include/lodox-macros.lfe")


;;;===================================================================
;;; API
;;;===================================================================

;; TODO: write a better docstring
(defun docs (app-name)
  "Given an app-name (binary), return a map like:

```commonlisp
'#m(name        #\"lodox\"
    version     \"0.7.0\"
    description \"The LFE rebar3 Lodox plugin\"
    documents   ()
    modules     {{list of maps of module metadata}}
    documented  #m(modules    {{map from module name to list of f/a strings}}
                   percentage {{percent documented (float)}}))
```"
  (let* ((app         (doto (binary_to_atom app-name 'latin1)
                            (application:load)))
         (app-info    (let ((`#(ok ,info) (application:get_all_key app)))
                        (maps:from_list info)))
         (modules     (mod-docs (mref app-info 'modules)))
         (version     (maps:get 'vsn         app-info ""))
         (documented  (documented modules))
         (description (maps:get 'description app-info ""))
         (libs        (lib-docs)))
    `#m(name        ,app-name
        version     ,version
        description ,description
        libs        ,libs
        modules     ,modules
        documented  ,documented)))

(defun form-doc
  "TODO: write docstring"
  ;; (defun name clause)
  ([(= `(defun ,name ,(= `[,arglist . ,_body] clause)) shape)]
   (when (is_atom name) (is_list arglist))
   (if (clause? clause)
     (ok-form-doc name (length arglist) `[,(pattern clause)] "")
     (unhandled-shape! shape)))

  ;; (defun name () form)
  ([`(defun ,name () ,_form)]
   (when (is_atom name))
   (ok-form-doc name 0 '[()] ""))

  ;; (defun name <doc|clause> clause)
  ;; (defun name arglist      form)
  ([`(defun ,name . ,(= `[,x ,y] rest))]
   (when (is_atom name))
   (cond
    ((clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest) ""))
    ((andalso (string? x) (clause? y))
     (ok-form-doc name (length (car y)) `[,(pattern y)] x))
    ((arglist? x)
     (ok-form-doc name (length x) `[,x] ""))))

  ;; (defun name doc clause)
  ([(= `(defun ,name ,doc-string ,(= `[,arglist . ,_body] clause)) shape)]
   (when (is_atom name) (is_list doc-string) (is_list arglist))
   (if (andalso (clause? clause) (string? doc-string))
     (ok-form-doc name (length arglist) `[,(pattern clause)] doc-string)
     (unhandled-shape! shape)))

  ;; (defun name () <doc|form> form)
  ([`(defun ,name () ,maybe-doc ,_form)]
   (when (is_atom name))
   (ok-form-doc name 0 '[()] (if (string? maybe-doc) maybe-doc "")))

  ;; (defun name "" clause clause ...?)
  ;; (defun name () doc    form   ...?)
  ([`(defun ,name () . ,(= `[,x . ,_] rest))]
   (if (clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest) "")
     (ok-form-doc name 0 '[()] (if (string? x) x ""))))

  ;; (defun name <doc|clause> clause     ...)
  ;; (defun name arglist      <doc|form> ...)
  ([`(defun ,name ,doc-or-arglist . ,(= `[,x . ,_] rest))]
   (when (is_atom name))
   (cond
    ((clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest)
                  (if (string? doc-or-arglist) doc-or-arglist "")))
    ((arglist? doc-or-arglist)
     (ok-form-doc name (length doc-or-arglist)
                  `[,doc-or-arglist] (if (string? x) x "")))))

  ;; (defun ...)
  ([(= `(defun . ,_) shape)]
   (unhandled-shape! shape))

  ;; (defmacro ...)
  ([(= `(defmacro . ,_) form)]
   (macro-doc form))

  ;; This pattern matches non-def{un,macro} forms.
  ([_] 'undefined))

(defun ok-form-doc (name arity arglists doc)
  `#(ok #m(name ,name arity ,arity arglists ,arglists doc ,doc)))

(defun form-doc (form line)
  "Equivalent to [[form-doc/3]] with `[]` as `exports`."
  (form-doc form line []))

(defun form-doc (form line exports)
  (case (form-doc form)
    (`#(ok ,(= `#m(name ,f arity ,a) doc))
     (iff (orelse (null? exports) (lists:member `#(,f ,a) exports))
       `#(true ,(mset doc 'line line))))
    ('undefined 'false)))

(defun macro-doc
  "TODO: write docstring"
  ;; (defmacro name clause)
  ([(= `(defmacro ,name ,clause) shape)]
   (when (is_atom name))
   (cond
    ((clause? clause)
     (ok-form-doc name (length (car clause)) `[,(pattern clause)] ""))
    ((macro-clause? clause)
     (ok-form-doc name 255 '[(...)] ""))
    ('true
     (unhandled-shape! shape))))
  ;; (defmacro name doc clause ...?)
  ([(= `(defmacro ,name ,x . ,(= `[,y . ,_] rest)) shape)]
   (when (is_atom name))
   (cond
    ((andalso (string? x) (macro-clauses? rest))
     (if (clause? y)
       (ok-form-doc name (length (car y)) (patterns rest) x)
       (ok-form-doc name 255 '[(...)] x)))
    ((arglist? x)
     (ok-form-doc name (length x) `[,x] (if (string? y) y "")))
    ('true
     (unhandled-shape! shape))))

  ;; (defmacro ...)
  ([(= `(defmacro . ,_) shape)]
   (unhandled-shape! shape))

  ;; This pattern matches non-defmacro forms.
  ([_] 'undefined))

(defun unhandled-shape! (shape)
  "Throw an error with `shape` pretty printed."
  (error (lists:flatten
          (io_lib:format "Unhandled shape: ~s~n"
            `[,(re:replace (lfe_io_pretty:term shape) "comma " ". ,"
                           '[global #(return list)])]))))

(defun lib-docs ()
  "Call [[lib-docs/1]] on each LFE file in `./include`."
  (lib-docs (filelib:wildcard (filename:absname "include/*.lfe"))))

(defun lib-docs (files)
  "Call [[lib-doc/1]] on each file in `files` and
return the list of non-empty results."
  (lists:filtermap #'lib-doc/1 files))

(defun lib-doc (filename)
  "Parse `filename` and attempt to return a tuple, `` `#(true ,defsmap) ``
where `defsmap` is a map representing the definitions in `filename`.
If [[file-doc/1]] returns the empty list, return `false`."
  (case (filename:extension filename)
    (".lfe" (case (file-doc filename)
              ('()     'false)
              (exports `#(true #m(name      ,(-> filename
                                                 (filename:basename ".lfe")
                                                 (list_to_atom))
                                  behaviour ""
                                  doc       ""
                                  exports   ,exports
                                  ;; dirty hack
                                  filepath  ,filename)))))
    (_      'false)))

(defun script-doc (filename)
  (if (filelib:is_file filename)
    (let* ((`#(ok ,file) (file:open filename '[read]))
           (tmp (drop-shebang filename file))
           (doc (file-doc tmp)))
      (file:delete tmp)
      doc)
    '()))

(defun documented (modules)
  (flet ((percentage
           ([`#(#(,n ,d) ,modules)]
            (->> `[,(* (/ n d) 100)]
                 (io_lib:format "~.2f")
                 (clj-comp:compose #'list_to_float/1 #'hd/1)
                 (mset `#m(undocumented ,modules) 'percentage)))))
    (->> modules
         (lists:foldl #'documented/2 #(#(0 0) #m()))
         (percentage))))

(defun documented
  ([`#m(exports ,exports name ,name) acc]
   (fletrec ((tally
               ([(= (map 'doc "") export) `#(#(,n ,d) ,m)]
                `#(#(,n ,(+ d 1))
                   ,(-> (func-name export)
                        (cons (maps:get name m []))
                        (->> (mset m name)))))
               ([`#m(doc ,_) `#(#(,n ,d) ,m)]
                `#(#(,(+ n 1) ,(+ d 1)) ,m))))
     (lists:foldl #'tally/2 acc exports))))


;;;===================================================================
;;; Internal functions
;;;===================================================================

(defun mod-behaviour (module)
  (let ((attributes (call module 'module_info 'attributes)))
    (proplists:get_value 'behaviour attributes '())))

(defun mod-docs
  ([mods] (when (is_list mods))
   (lists:filtermap #'mod-docs/1 mods))
  ([mod]  (when (is_atom mod))
   (let ((file (proplists:get_value 'source (call mod 'module_info 'compile))))
     (case (filename:extension file)
       (".lfe" (case (mod-docs file (call mod 'module_info 'exports))
                 ('()     'false)
                 (exports `#(true #m(name      ,(mod-name mod)
                                     behaviour ,(mod-behaviour mod)
                                     doc       ,(mod-doc mod)
                                     exports   ,exports
                                     ;; dirty hack
                                     filepath  ,file)))))
       (_      'false)))))

(defun mod-docs (file exports)
  (if (filelib:is_file file)
    (let ((`#(ok ,forms) (lfe_io:parse_file file)))
      (lists:filtermap
        (match-lambda ([`#(,form ,line)] (form-doc form line exports)))
        forms))
    '()))

(defun mod-doc
  ([module] (when (is_atom module))
   (let ((attributes (call module 'module_info 'attributes)))
     (proplists:get_value 'doc attributes ""))))

(defun mod-name (mod) (call mod 'module_info 'module))

(defun drop-shebang (filename file)
  (let ((`#(ok [#\# #\! . ,_]) (file:read_line file))
        (tmp-file (tmp-filename filename)))
    (file:copy file tmp-file)
    tmp-file))

(defun tmp-filename (filename)
  (string:concat filename ".tmp"))

(defun file-doc (filename)
  (if (filelib:is_file filename)
    (let ((`#(ok ,forms) (lfe_io:parse_file filename)))
      (lists:filtermap
        (match-lambda
          ([`#(,form ,line)] (form-doc form line)))
        forms))
    '()))

(defun patterns (forms) (lists:map #'pattern/1 forms))

(defun pattern
  ([`(,patt ,(= guard `(when . ,_)) . ,_)] `(,@patt ,guard))
  ([`(,arglist . ,_)] arglist))

(defun func-name
  "Given a parsed def{un,macro} form (map), return a string, `\"name/arity\"`."
  ([`#m(name ,name arity ,arity)]
   (->> `[,name ,arity] (io_lib:format "~s/~w") (lists:flatten))))
#+END_SRC

** lodox-p
   :PROPERTIES:
   :tangle:   ../src/lodox-p.lfe
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox-p.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+NAME: lodox-p
#+BEGIN_SRC lfe :padline yes
(defmodule lodox-p
  (export (macro-clauses? 1) (macro-clause? 1)
          (clauses? 1) (clause? 1)
          (arglist? 1) (arg? 1)
          (string? 1)
          (null? 1)))

(defun macro-clauses? (forms)
  "Return `true` iff `forms` is a list of items satisfying [[macro-clause?/1]]."
  (lists:all #'macro-clause?/1 forms))

(defun macro-clause? (form)
  "Given a term, return `true` iff it seems like a macro clause.
A macro clause either satisfies [[clause?/1]] without alteration or when
its head in encapsulated in a list."
  (orelse (clause? form)
          (clause? `([,(car form)] . ,(cdr form)))))

(defun clauses? (forms)
  "Return `true` iff `forms` is a list of items that satisfy [[clause?/1]]."
  (andalso (lists:all #'clause?/1 forms)
           (let ((arity (length (caar forms))))
             (lists:all (lambda (form) (=:= (length (car form)) arity)) forms))))

(defun clause?
  "Given a term, return `true` iff it is a list whose head satisfies [[arglist?/1]]."
  ([`(,_)]      'false)
  ([`([] . ,_)] 'false)
  ([`(,h . ,_)] (arglist? h))
  ([_]          'false))

(defun arglist?
  "Given a term, return `true` iff it is either the empty list or a list
such that all elements satisfy [[arg?/1]]."
  (['()]                      'true)
  ([lst] (when (is_list lst)) (lists:all #'arg?/1 lst))
  ([_]                        'false))

(defun arg?
  "Return `true` iff `x` seems like a valid item in an arglist."
  ([(= x `(,h . ,_t))]
   (orelse (string? x)
           (lists:member h '(= () backquote quote binary list map tuple))
           (andalso (is_atom h) (lists:prefix "match-" (atom_to_list h)))))
  ([x]
   (lists:any (lambda (p) (funcall p x))
              (list #'is_atom/1
                    #'is_binary/1
                    #'is_bitstring/1
                    #'is_number/1
                    #'is_map/1
                    #'is_tuple/1
                    #'string?/1))))

(defun string? (data)
  "Return `true` iff `data` is a flat list of printable characters."
  (io_lib:printable_list data))

(defun null?
  "Return `true` iff `data` is the empty list."
  (['()] 'true)
  ([_]   'false))
#+END_SRC

** lodox-util
   :PROPERTIES:
   :tangle:   ../src/lodox-util.lfe
   :padline:  yes
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/src/lodox-util.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+NAME: lodox-util
#+BEGIN_SRC lfe :padline yes
(defmodule lodox-util
  (doc "Utility functions to inspect the current version of lodox and its dependencies.")
  (export (search-funcs 2) (search-funcs 3)))

(defun search-funcs (modules partial-func)
  "TODO: write docstring"
  (search-funcs modules partial-func 'undefined))

(defun search-funcs (modules partial-func starting-mod)
  "TODO: write docstring"
  (let* ((suffix  (if (lists:member #\/ partial-func)
                    partial-func
                    `(#\/ . ,partial-func)))
         (matches (lists:filter
                    (lambda (func-name) (lists:suffix suffix func-name))
                    (exported-funcs modules))))
    (case (lists:dropwhile
           (lambda (func-name)
             (=/= (atom_to_list starting-mod) (module func-name)))
           matches)
      (`(,func . ,_) func)
      ('()           (case matches
                       (`(,func . ,_) func)
                       ('()           'undefined))))))
#+END_SRC
#+BEGIN_SRC lfe :exports none :padline no
#+END_SRC
#+BEGIN_SRC lfe :exports none
;;;===================================================================
;;; Internal functions
;;;===================================================================
#+END_SRC
#+BEGIN_SRC lfe
(defun exported-funcs (modules)
  "TODO: write docstring"
  (lc ((<- mod modules)
       (<- func (mref mod 'exports)))
    (func-name mod func)))

(defun func-name (mod func)
  "TODO: write docstring"
  (++ (atom_to_list (mref mod 'name))
      ":" (atom_to_list (mref func 'name))
      "/" (integer_to_list (mref func 'arity))))

(defun module (func-name)
  (lists:takewhile (lambda (c) (=/= c #\:)) func-name))
#+END_SRC

* Macros
  :PROPERTIES:
  :noweb:    yes
  :END:
#+BEGIN_SRC lfe :exports none :tangle ../include/lodox-macros.lfe
<<generated()>>
#+END_SRC

Inspired by [[http://clojuredocs.org/clojure.core/doto][Clojure]], ~doto~ takes a term ~x~ and threads it through given
s-expressions as the first argument, e.g. ~(-> x (f y z))~, or functions,
e.g. ~(funcall #'g/1 x)~, evaluating them for their side effects, and then
returns ~x~.
#+BEGIN_SRC lfe
(defmacro doto
  <<doto>>)
#+END_SRC

Also known as ~when~ in other languages, ~iff~ takes a ~test~ that returns a
boolean and a ~then~ branch of an ~if~ expression, and returns ~then~ iff
~test~, otherwise ~false~.

N.B. ~iff~ cannot be called ~when~ in LFE, since ~when~ is reserved for guards.

#+BEGIN_SRC lfe
(defmacro iff (test then) <<iff>>)
#+END_SRC

#+BEGIN_SRC lfe :exports none :tangle ../include/lodox-macros.lfe
(defmacro doto
  "Evaluate all given s-expressions and functions in order,
for their side effects, with the value of `x` as the first argument
and return `x`."
  <<doto>>)
#+END_SRC
#+NAME: doto
#+BEGIN_SRC lfe :exports none
(`(,x . ,sexps)
 `(let ((,'x* ,x))
    ,@(lists:map
        (match-lambda
          ([`(,f . ,args)] `(,f ,'x* ,@args))
          ([f]             `(,f ,'x*)))
        sexps)
    ,'x*))
#+END_SRC

#+BEGIN_SRC lfe :exports none :tangle ../include/lodox-macros.lfe
(defmacro iff (test then)
  "Given a `test` that returns a boolean, if `test` is `true`, return `then`,
  otherwise `false`."
  <<iff>>)
#+END_SRC
#+NAME: iff
#+BEGIN_SRC lfe :exports none
`(if ,test ,then)
#+END_SRC

* Tests
  :PROPERTIES:
  :noweb:    yes
  :END:
** Property Tests
   :PROPERTIES:
   :tangle:   ../test/lodox_parse_tests.erl
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/test/lodox_parse_tests.erl][Source]]
#+BEGIN_SRC erlang :exports none
<<generated("erlang")>>
#+END_SRC
#+BEGIN_SRC erlang
-module(lodox_parse_tests).

-compile(export_all).

-include_lib("proper/include/proper.hrl").

-include_lib("eunit/include/eunit.hrl").

-define(TIMEOUT, 90).

-define(OPTIONS(N), [{on_output, fun pprint/2}, {numtests, N}]).


%%%===================================================================
%%% EUnit tests
%%%===================================================================

parse_test_() ->
  Properties =
    [ {"A function without a docstring produces an empty docstring.",
       prop_defun_simple(), 500}
    , {"A simple function with a docstring is correctly parsed.",
       prop_defun_simple_doc(), 500}
    , {"A function with pattern clauses produces an empty docstring.",
       prop_defun_match(), 40}
    , {"A function with pattern clauses and a docstring is correctly parsed.",
       prop_defun_match_doc(), 30}
    ],
  [{timeout, ?TIMEOUT,
    {Title, ?_assert(proper:quickcheck(Property, ?OPTIONS(NumTests)))}}
   || {Title, Property, NumTests} <- Properties].


%%%===================================================================
%%% Properties
%%%===================================================================

prop_defun_simple() ->
  ?FORALL(D, defun_simple(),
          begin
            {ok, #{doc := Doc}} = 'lodox-parse':'form-doc'(D),
            "" =:= Doc
          end).

prop_defun_simple_doc() ->
  ?FORALL(Defun, defun_simple_doc(),
          begin
            {ok, #{doc := Doc}} = 'lodox-parse':'form-doc'(Defun),
            lists:nth(4, Defun) =:=  Doc
          end).

prop_defun_match() ->
  ?FORALL(Defun, defun_match(),
          begin
            {ok, #{doc := Doc}} = 'lodox-parse':'form-doc'(Defun),
            "" =:= Doc
          end).

prop_defun_match_doc() ->
  ?FORALL(Defun, defun_match_doc(),
          begin
            {ok, #{doc := Doc}} = 'lodox-parse':'form-doc'(Defun),
            lists:nth(3, Defun) =:=  Doc
          end).


%%%===================================================================
%%% defun shapes
%%%===================================================================

defun_simple() ->
  [defun, atom(), arglist_simple()
   | body()].

defun_simple_doc() ->
  [defun, atom(), arglist_simple(),
   docstring()
   | body()].

defun_match() ->
  Arity = random:uniform(10),
  [defun, atom()
   | non_empty(list(pattern_clause(Arity)))].

defun_match_doc() ->
  Arity = random:uniform(10),
  [defun, atom(),
   docstring()
   | non_empty(list(pattern_clause(Arity)))].


%%%===================================================================
%%% Custom types
%%%===================================================================

%%% Functions

arglist_simple() -> list(atom()).

body() -> union([[printable_string()], [non_string_term() | list(form())]]).

form() -> union([non_string_term(), printable_string(), [atom() | list()]]).

docstring() -> printable_string().

arglist_patterns(Arity) -> vector(Arity, pattern()).


%%% Patterns

pattern() -> union([non_string_term(), printable_string(), pattern_form()]).

pattern_form() ->
  [oneof([backquote, quote, binary, list, map, tuple, match_fun()])
   | non_empty(list())].

match_fun() -> ?LET(F, printable_string(), list_to_atom("match-" ++ F)).

pattern_clause(Arity) ->
  [arglist_patterns(Arity) |
   [oneof([guard(), form()]) | body()]].

guard() -> ['when' | non_empty(list(union([logical_clause(), comparison()])))].


%%% Logical clauses

logical_clause() ->
  X = union([atom(), comparison()]),
  [logical_operator(), X | non_empty(list(X))].

logical_operator() -> oneof(['and', 'andalso', 'or', 'orelse']).


%%% Comparisons

comparison() -> [comparison_operator(), atom() | list(atom())].

comparison_operator() -> oneof(['==', '=:=', '=/=', '<', '>', '=<', '>=']).


%%% Strings and non-strings

non_string_term() ->
  union([atom(), number(), [], bitstring(), binary(), boolean(), tuple()]).

printable_char() -> union([integer(32, 126), integer(160, 255)]).

printable_string() -> list(printable_char()).


%%%===================================================================
%%% Internal functions
%%%===================================================================

pprint(_Format, [Defun]) when defun =:= hd(Defun) ->
  io:format(user, "~s~n", [pprint(Defun)]);
pprint(Format, Data) ->
  io:format(user, Format, Data).

pprint(Term) ->
  re:replace(lfe_io_pretty:term(Term), "comma ", ". ,",
             [global, {return, list}]).
#+END_SRC
** Unit Tests
   :PROPERTIES:
   :tangle:   ../test/unit-lodox-tests.lfe
   :END:
[[https://github.com/quasiquoting/lodox/blob/master/test/unit-lodox-tests.lfe][Source]]
#+BEGIN_SRC lfe :exports none
<<generated()>>
#+END_SRC
#+BEGIN_SRC lfe
(defmodule unit-lodox-tests
  (behaviour ltest-unit)
  (export (projects_shapes_test_ 0)
          (modules_shapes_test_  0)
          (exports_shapes_test_  0)))

(include-lib "ltest/include/ltest-macros.lfe")
#+END_SRC

*** ~project~ Shapes
#+BEGIN_SRC lfe
(deftestgen projects-shapes
  (lists:zipwith #'validate_project/2 (src-dirs) (all-docs)))

;; EUnit gets very upset if the following _ is a -.
(defun validate_project (dir project)
  `[#(#"project is a map"
      ,(_assert (is_map project)))
    #(#"description is a string"
      ,(_assert (lodox-p:string? (mref* project 'description))))
    #(#"libs is a list"
      ,(_assert (is_list (mref* project 'libs))))
    #(#"modules is a list"
      ,(_assert (is_list (mref* project 'modules))))
    #(#"name matches directory"
      ,(_assertEqual (project-name dir) (mref* project 'name)))
    #(#"version is a list"
      ,(_assert (is_list (mref* project 'version))))])
#+END_SRC

*** ~modules~ Shapes
#+BEGIN_SRC lfe
(deftestgen modules-shapes
  (lists:map #'validate_module/1 (project-wide 'modules)))

(defun validate_module (module)
  `[#(#"module is a map"
      ,(_assert (is_map module)))
    #(#"module has correct keys"
      ,(_assertEqual '(behaviour doc exports filepath name) (maps:keys module)))
    #(#"behaviour is a list of atoms"
      ,(_assert (lists:all #'is_atom/1 (mref* module 'behaviour))))
    #(#"doc is a list"
      ,(_assert (is_list (mref* module 'doc))))
    #(#"exports is a list"
      ,(_assert (is_list (mref* module 'exports))))
    #(#"filepath refers to a regular file"
      ,(_assert (filelib:is_regular (mref* module 'filepath))))
    #(#"name is an atom"
      ,(_assert (is_atom (mref* module 'name))))])
#+END_SRC

*** ~exports~ Shapes
#+BEGIN_SRC lfe
(deftestgen exports-shapes
  (lists:map #'validate_exports/1 (project-wide 'exports 'modules)))

(defun validate_exports (exports)
  `[#(#"exports is a map"
      ,(_assert (is_map exports)))
    #(#"exports has correct keys"
      ,(_assertEqual '(arglists arity doc line name) (maps:keys exports)))
    #(#"arglists is a list of arglists (which may end with a guard)"
      ,(let ((arglists (lists:map
                         (lambda (arglist)
                           (lists:filter
                             (match-lambda
                               ([`(when . ,_t)] 'false)
                               ([_]             'true))
                             arglist))
                         (mref* exports 'arglists))))
         (_assert (lists:all #'lodox-p:arglist?/1 arglists))))
    #(#"artity is an integer"
      ,(_assert (is_integer (mref* exports 'arity))))
    #(#"doc is a string"
      ,(_assert (lodox-p:string? (mref* exports 'doc))))
    #(#"line is an integer"
      ,(_assert (is_integer (mref* exports 'line))))
    #(#"name is an atom"
      ,(_assert (is_atom (mref* exports 'name))))])
#+END_SRC
#+BEGIN_SRC lfe :exports none
#+END_SRC
#+BEGIN_SRC lfe :exports none :padline no
;;;===================================================================
;;; Internal functions
;;;===================================================================

(defun all-docs () (lists:map #'lodox-parse:docs/1 '(#"lodox")))

(defun mref* (m k) (maps:get k m 'error))

(defun project-name
  (["src"] #"lodox")
  ([dir]   (filename:basename (filename:dirname dir))))

(defun project-wide
  ([f]   (when (is_function f)) (lists:flatmap f (all-docs)))
  ([key]                        (project-wide (lambda (proj) (mref* proj key)))))

(defun project-wide (key2 key1)
  (project-wide
   (lambda (proj) (lists:flatmap (lambda (m) (mref* m key2)) (mref* proj key1)))))

(defun src-dirs () '("src"))
#+END_SRC

* Travis CI
  :PROPERTIES:
  :tangle:   ../.travis.yml
  :noweb:    yes
  :END:
[[https://travis-ci.org/quasiquoting/lodox][Link]]
#+BEGIN_SRC yaml :exports none
<<generated("yaml")>>
#+END_SRC
#+BEGIN_SRC yaml :padline yes
language: erlang
# http://stackoverflow.com/a/24600210/1793234
# Handle git submodules yourself
git:
  submodules: false
# Use sed to replace the SSH URL with the public URL, then initialize submodules
before_install:
  - sed -i 's/git@github.com:/https:\/\/github.com\//' .gitmodules
  - git submodule update --init --recursive
install: true
before_script:
    - wget https://s3.amazonaws.com/rebar3/rebar3
    - chmod 755 rebar3
script:
  - ./rebar3 eunit -v
notifications:
  email:
    - quasiquoting@gmail.com
otp_release:
  - 18.2
  - 18.0
#+END_SRC

#+INCLUDE: LICENSE.org :minlevel 1
