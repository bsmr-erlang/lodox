;;;===================================================================
;;; This file was generated by Org. Do not edit it directly.
;;; Instead, edit Lodox.org in Emacs and call org-babel-tangle.
;;;===================================================================

(defmodule lodox-parse
  (doc "Parsing LFE source files for metadata.")
  (export (docs 1)
          (form-doc 1))
  (import (from lodox-p
            (arglist? 1)
            (clause? 1)
            (clauses? 1)
            (string? 1)
            (null? 1))))

(include-lib "clj/include/compose.lfe")

(include-lib "lodox/include/lodox-macros.lfe")


;;;===================================================================
;;; API
;;;===================================================================

;; TODO: write a better docstring
(defun docs (app-name)
  "Given an app-name (binary), return a map like:

```commonlisp
'#m(name        #\"lodox\"
    version     \"0.5.5\"
    description \"The LFE rebar3 Lodox plugin\"
    documents   ()
    modules     {{list of maps of module metadata}})
```"
  (let* ((app         (doto (binary_to_atom app-name 'latin1)
                            (application:load)))
         (app-info    (let ((`#(ok ,info) (application:get_all_key app)))
                        (maps:from_list info)))
         (modules     (mod-docs (mref app-info 'modules)))
         (version     (maps:get 'vsn         app-info ""))
         (description (maps:get 'description app-info "")))
    `#m(name        ,app-name
        version     ,version
        description ,description
        documents   []
        modules     ,modules)))


;;;===================================================================
;;; Internal functions
;;;===================================================================

(defun form-doc
  "TODO: write docstring"
  ;; (defun name clause)
  ([`(defun ,name ,(= `[,arglist . ,_body] clause))]
   (when (is_atom name) (is_list arglist))
   (if (clause? clause)
     (ok-form-doc name (length arglist) `[,(pattern clause)] "")
     (error "Unhandled shape!")))

  ;; (defun name () form)
  ([`(defun ,name () ,_form)]
   (when (is_atom name))
   (ok-form-doc name 0 '[()] ""))

  ;; (defun name <doc|clause> clause)
  ;; (defun name arglist      form)
  ([`(defun ,name . ,(= `[,x ,y] rest))]
   (when (is_atom name))
   (cond
    ((clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest) ""))
    ((andalso (string? x) (clause? y))
     (ok-form-doc name (length (car y)) `[,(pattern y)] x))
    ((arglist? x)
     (ok-form-doc name (length x) `[,x] ""))))

  ;; (defun name doc clause)
  ([`(defun ,name ,doc-string ,(= `[,arglist . ,_body] clause))]
   (when (is_atom name) (is_list doc-string) (is_list arglist))
   (if (andalso (clause? clause) (string? doc-string))
     (ok-form-doc name (length arglist) `[,(pattern clause)] doc-string)
     (error "Unhandled shape!")))

  ;; (defun name () <doc|form> form)
  ([`(defun ,name () ,maybe-doc ,_form)]
   (when (is_atom name))
   (ok-form-doc name 0 '[()] (if (string? maybe-doc) maybe-doc "")))

  ;; (defun name "" clause clause)
  ;; (defun name () doc    form)
  ([`(defun ,name () . ,(= `[,x . ,_] rest))]
   (if (clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest) "")
     (ok-form-doc name 0 '[()] (if (string? x) x ""))))

  ;; (defun name () clause     clause clause)
  ;; (defun name () <doc|form> form   form)
  ([`(defun ,name () . ,(= `[,x ,y ,z] rest))]
   (when (is_atom name))
   (if (clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest) "")
     (ok-form-doc name 0 '[()] (if (string? x) x ""))))

  ;; (defun name <doc|clause> clause     clause clause)
  ;; (defun name arglist      <doc|form> form   form)
  ([`(defun ,name ,doc-or-arglist . ,(= `[,x ,y ,z] rest))]
   (when (is_atom name))
   (cond
    ((clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest)
                  (if (string? doc-or-arglist) doc-or-arglist "")))
    ((arglist? doc-or-arglist)
     (ok-form-doc name (length doc-or-arglist)
                  `[,doc-or-arglist] (if (string? x) x "")))))

  ;; (defun name <doc|clause> clause ...)
  ;; (defun name <doc|form>   form   ...)
  ([`(defun ,name ,doc-or-arglist . ,(= `[,x . ,_] rest))]
   (when (is_atom name))
   (cond
    ((clauses? rest)
     (ok-form-doc name (length (car x)) (patterns rest)
                  (if (string? doc-or-arglist) doc-or-arglist "")))
    ((arglist? doc-or-arglist)
     (ok-form-doc name (length doc-or-arglist)
                  `[,doc-or-arglist] (if (string? x) x "")))))

  ;; (defun ...)
  ([(= `(defun . ,_) shape)]
   (error "Unhandled shape: ~s~n"
          `[,(re:replace (lfe_io_pretty:term shape) "comma " ". ,"
                         '[global #(return list)])]))

  ;; This pattern matches non-defun forms.
  ([_] 'undefined))

(defun ok-form-doc (name arity arglists doc)
  `#(ok #m(name ,name arity ,arity arglists ,arglists doc ,doc)))

(defun form-doc (form line)
  "Equivalent to [[form-doc/3]] with `[]` as `exports`."
  (form-doc form line []))

(defun form-doc (form line exports)
  (case (form-doc form)
    (`#(ok ,(= `#m(name ,f arity ,a) doc))
     (iff (orelse (null? exports) (lists:member `#(,f ,a) exports))
       `#(true ,(mset doc 'line line))))
    ('undefined 'false)))

(defun mod-behaviour (module)
  (let ((attributes (call module 'module_info 'attributes)))
    (proplists:get_value 'behaviour attributes '())))

(defun mod-docs
  ([mods] (when (is_list mods))
   (lists:filtermap #'mod-docs/1 mods))
  ([mod]  (when (is_atom mod))
   (let ((file (proplists:get_value 'source (call mod 'module_info 'compile))))
     (case (filename:extension file)
       (".lfe" (case (mod-docs file (call mod 'module_info 'exports))
                 ('()     'false)
                 (exports `#(true #m(name      ,(mod-name mod)
                                     behaviour ,(mod-behaviour mod)
                                     doc       ,(mod-doc mod)
                                     exports   ,exports
                                     ;; dirty hack
                                     filepath  ,file)))))
       (_      'false)))))

(defun mod-docs (file exports)
  (if (filelib:is_file file)
    (let ((`#(ok ,forms) (lfe_io:parse_file file)))
      (lists:filtermap
        (match-lambda ([`#(,form ,line)] (form-doc form line exports)))
        forms))
    '()))

(defun mod-doc
  ([module] (when (is_atom module))
   (let ((attributes (call module 'module_info 'attributes)))
     (proplists:get_value 'doc attributes ""))))

(defun mod-name (mod) (call mod 'module_info 'module))

(defun patterns (forms) (lists:map #'pattern/1 forms))

(defun pattern
  ([`(,patt ,(= guard `(when . ,_)) . ,_)] `(,@patt ,guard))
  ([`(,arglist . ,_)] arglist))
